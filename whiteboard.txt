Write anything and everthing. Steps to do/set-up everythning, changes made, features added or want to add. 

Milestone 1:
	Done

Milestone 2:
	data dump? - Done
	queries - Done
	indexes - Done
	performance metrics - Done

Milestone 3:
	Final submission
	Application front end design 
	Supported transactions 
	Overall architecture 
	Demonstration scenario
	It should cover all the aspects of the proposed application (full spectrum of the queries and transactions)


Github:
	Clone repo: 							git clone https://github.com/Vinit-Chandak/SMV
	Switch to different milestones/main: 	git checkout -b breanch_name
	stage changes: 							git add .
	commit changes: 						git commit -m "what changes were made, message"
	push changes: 							git push
	regularly pull changes:					git pull
	merge branches: 						git merge branch_name
	delete branch:							git branch --delete branch_name
	see all branches:						git branch -a
	



Ui/Ux:





Database:
	url: http://10.17.50.91:5000/
	usename: group_13
	password: QcNtcHm7Hmqg9q
	
	Data dumps:
		1. Initial Dump
		2. Dump with index
		3. Dump with changed structure and triggers.




Setup:
	Install python
	
	Set up a virtual environment if wanted:
		pip install virtualenv
		in projects root directory: virtualenv venv
		activate venvm: windows - .\venv\Scripts\activate, mac/linux - source venv/bin/activate
		deactivate venvm: deactivate
		add venv to .gitignore
	
	install delpendencies from requirements.txt
	How to create requirements.txt?
		pip freeze > requirements.txt
			This command will generate a list of all the installed packages in your current virtual environment (or system Python installation if not using a virtual environment), along with their version numbers, and save this list to a file named requirements.txt.
		or add manually, find versions using pip freeze

	pip install Flask Flask-SQLAlchemy psycopg2 requests plotly pandas

	Run the application:
		python app.py
		http://127.0.0.1:5000/


Local Database:
	
	Dump database:
		/usr/local/pgsql/bin/pg_dump -h localhost -U postgres -f db_dump_project.sql prod
		
	Load dump:
		 /usr/local/pgsql/bin/psql -U postgres -W -f triggers_dump.sql prod

	Reset database:
		DROP SCHEMA public CASCADE;
		CREATE SCHEMA public;
		GRANT ALL ON SCHEMA public TO postgres;
		GRANT ALL ON SCHEMA public TO public;
		\i /usr/local/pgsql/bin/helo/database_structure.sql
		\i /usr/local/pgsql/bin/helo/import_database.sql
		 
	Changed the structure and added ON DELETE cascades to all the foreign keys.
	
	Triggers:
		
		CREATE LANGUAGE plpgsql;
		
		For enforcing data integrity:

			Ensuring that a new entry in the Average_Temperature table has a valid temperature value.
	
			CREATE OR REPLACE FUNCTION check_valid_temperature()
			RETURNS TRIGGER AS $$
			BEGIN
			IF NEW.Average_Temperature < -273.15 THEN
				RAISE EXCEPTION 'Invalid temperature value: below absolute zero.';
			END IF;
			RETURN NEW;
			END;
			$$ LANGUAGE plpgsql;

			CREATE TRIGGER trg_check_valid_temperature
			BEFORE INSERT OR UPDATE ON Average_Temperature
			FOR EACH ROW
			EXECUTE PROCEDURE check_valid_temperature();

			INSERT INTO Average_Temperature (State, Month, Year, Average_Temperature, average_temperature_uncertainity) VALUES ('Maharashtra', 11, 2023, -280, 0.1);
		
		For cascading actions:

			If the capital of a state is updated, then it is also updated in all the relevent tables.

			CREATE OR REPLACE FUNCTION update_state_capital()
			RETURNS TRIGGER AS $$
			BEGIN
			-- Check if the capital has changed
			IF OLD.Capital <> NEW.Capital THEN
				-- Update the capital in the Cities table
				UPDATE Cities
				SET City = NEW.Capital
				WHERE City = OLD.Capital
				AND State = NEW.State;

				-- Update the capital in the Sealevel table
				UPDATE Sealevel
				SET Sea_Shore_City = NEW.Capital
				WHERE Sea_Shore_City = OLD.Capital
				AND State = NEW.State;
			END IF;
			RETURN NEW;
			END;
			$$ LANGUAGE plpgsql;

			CREATE TRIGGER trg_update_state_capital
			AFTER UPDATE ON States
			FOR EACH ROW
			EXECUTE PROCEDURE update_state_capital();

		For auto updates:

			Automatically calculating the Annual and quarterly rainfall in the Rainfall table based on the monthly values.

			CREATE OR REPLACE FUNCTION calculate_annual_quarterly_rainfall()
			RETURNS TRIGGER AS $$
			BEGIN
				-- Calculate Annual rainfall
				NEW.Annual = COALESCE(NEW.January, 0) + COALESCE(NEW.February, 0) + COALESCE(NEW.March, 0) + COALESCE(NEW.April, 0)
							+ COALESCE(NEW.May, 0) + COALESCE(NEW.June, 0) + COALESCE(NEW.July, 0) + COALESCE(NEW.August, 0)
							+ COALESCE(NEW.September, 0) + COALESCE(NEW.October, 0) + COALESCE(NEW.November, 0) + COALESCE(NEW.December, 0);

				-- Calculate quarterly rainfall
				NEW.January_February = COALESCE(NEW.January, 0) + COALESCE(NEW.February, 0);
				NEW.March_May = COALESCE(NEW.March, 0) + COALESCE(NEW.April, 0) + COALESCE(NEW.May, 0);
				NEW.June_September = COALESCE(NEW.June, 0) + COALESCE(NEW.July, 0) + COALESCE(NEW.August, 0) + COALESCE(NEW.September, 0);
				NEW.October_December = COALESCE(NEW.October, 0) + COALESCE(NEW.November, 0) + COALESCE(NEW.December, 0);

				RETURN NEW;
			END;
			$$ LANGUAGE plpgsql;

			CREATE TRIGGER trg_calculate_annual_quarterly_rainfall
			BEFORE INSERT OR UPDATE ON Rainfall
			FOR EACH ROW
			EXECUTE PROCEDURE calculate_annual_quarterly_rainfall();

		For logging:

			Created a trigger to log changes in the average_temperature table.

			CREATE TABLE average_temperature_audit (
				audit_id SERIAL PRIMARY KEY,
				operation VARCHAR(10) NOT NULL,
				state VARCHAR(30),
				month VARCHAR(15),
				year INT,
				old_avg_temperature NUMERIC(6, 3),
				new_avg_temperature NUMERIC(6, 3),
				old_avg_temperature_uncertainty NUMERIC(5, 3),
				new_avg_temperature_uncertainty NUMERIC(5, 3),
				changed_by VARCHAR(100) NOT NULL,
				changed_at TIMESTAMP NOT NULL
			);

			CREATE OR REPLACE FUNCTION average_temperature_audit_trigger_func()
			RETURNS TRIGGER AS $$
			BEGIN
				IF TG_OP = 'UPDATE' THEN
					INSERT INTO average_temperature_audit (
						operation, state, month, year,
						old_avg_temperature, new_avg_temperature,
						old_avg_temperature_uncertainty, new_avg_temperature_uncertainty,
						changed_by, changed_at
					)
					VALUES (
						'UPDATE', NEW.state, NEW.month, NEW.year,
						OLD.average_temperature, NEW.average_temperature,
						OLD.average_temperature_uncertainty, NEW.average_temperature_uncertainty,
						current_user, current_timestamp
					);
					RETURN NEW;
				ELSIF TG_OP = 'DELETE' THEN
					INSERT INTO average_temperature_audit (
						operation, state, month, year,
						old_avg_temperature, new_avg_temperature,
						old_avg_temperature_uncertainty, new_avg_temperature_uncertainty,
						changed_by, changed_at
					)
					VALUES (
						'DELETE', OLD.state, OLD.month, OLD.year,
						OLD.average_temperature, NULL,
						OLD.average_temperature_uncertainty, NULL,
						current_user, current_timestamp
					);
					RETURN OLD;
				ELSIF TG_OP = 'INSERT' THEN
					INSERT INTO average_temperature_audit (
						operation, state, month, year,
						old_avg_temperature, new_avg_temperature,
						old_avg_temperature_uncertainty, new_avg_temperature_uncertainty,
						changed_by, changed_at
					)
					VALUES (
						'INSERT', NEW.state, NEW.month, NEW.year,
						NULL, NEW.average_temperature,
						NULL, NEW.average_temperature_uncertainty,
						current_user, current_timestamp
					);
					RETURN NEW;
				END IF;
			END;
			$$ LANGUAGE plpgsql;

			CREATE TRIGGER average_temperature_audit_trigger
			AFTER INSERT OR UPDATE OR DELETE ON average_temperature
			FOR EACH ROW
			EXECUTE PROCEDURE average_temperature_audit_trigger_func();




	
Database Features Implemented:
	1. Deferred foreign key constraints on states and cities mitigating the circular dependency.
	2. ON DELETE CASCADE on all the foreign keys.
	3. Indexes.
	4. Trigger for data integrity.
	5. Trigger for cascading actions.
	6. Trigger for auto updates.
	7. Logging - Created a log table which tracks changes in the average_temperature table.
	8. Trigger for logging.
	9. Materialized Views.
		
		Created a materialized view to display the total CO2 emissions for each state.
		
		CREATE MATERIALIZED VIEW total_state_co2_emissions AS
		SELECT State, SUM(CO2_Emissions) as total_co2_emissions
		FROM State_CO2
		GROUP BY State;
		
		
		Created a materialized view that'll keep tab on all the cities where aqi quality bucket has been "Very Poor" in the past decade.
		
		CREATE MATERIALIZED VIEW severe_aqi_cities_past_decade AS
		SELECT
			City,
			State,
			COUNT(*) AS num_severe_days
		FROM
			AQI
		WHERE
			AQI_Bucket = 'Very Poor'
			AND Date >= (current_date - INTERVAL '10 years')
		GROUP BY
			City, State
		HAVING
			COUNT(*) > 0
		ORDER BY
			num_severe_days DESC;
		
		REFRESH MATERIALIZED VIEW severe_aqi_cities_past_decade;

	10. 	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
BEGIN;

-- Insert values into States table
INSERT INTO States (State, Capital)
VALUES ('Maharashtra', 'Mumbai');

INSERT INTO Cities (City, State)
VALUES ('Mumbai', 'Maharashtra');

INSERT INTO State_Subdivision (State, Subdivision)
VALUES ('Maharashtra', 'SampleSubdivision');

INSERT INTO State_CO2 (State, Year, CO2_Emissions)
VALUES ('Maharashtra', 2022, 12345.67);

INSERT INTO Average_Temperature (Average_Temperature, State, Month, Year)
VALUES
(10.123, 'Maharashtra', 'January', 2022),
(12.345, 'Maharashtra', 'February', 2022),
(14.567, 'Maharashtra', 'March', 2022),
(16.789, 'Maharashtra', 'April', 2022),
(-300, 'Maharashtra', 'May', 2022),
(20.123, 'Maharashtra', 'June', 2022),
(22.345, 'Maharashtra', 'July', 2022),
(24.567, 'Maharashtra', 'August', 2022),
(26.789, 'Maharashtra', 'September', 2022),
(28.901, 'Maharashtra', 'October', 2022),
(30.123, 'Maharashtra', 'November', 2022),
(32.345, 'Maharashtra', 'December', 2022);

COMMIT;

	
	
	
	
	
	
	
	
	
	
